## üß† TD : Impl√©mentation du Lambda-Calcul en OCaml

### üìù Objectif :
Programmer un interpr√©teur minimal du lambda-calcul non typ√© en OCaml. Vous manipulerez des expressions, ferez des substitutions, et √©valuerez des termes selon les r√®gles du lambda-calcul.

---

### üîß Partie 1 : Repr√©sentation des termes

1. **D√©finissez un type pour repr√©senter les termes du lambda-calcul.**
   - R√©fl√©chissez aux trois formes possibles d‚Äôun terme.
   - Donnez des noms clairs √† vos constructeurs.

2. **Ajoutez une fonction `string_of_term : term -> string`**
   - Elle doit convertir une expression en une cha√Æne lisible, avec les parenth√®ses n√©cessaires.
   - Pensez √† bien g√©rer la priorit√© des op√©rateurs (application vs abstraction).

---

### ‚öôÔ∏è Partie 2 : Substitution

3. **Impl√©mentez une fonction de substitution `subst : string -> term -> term -> term`**
   - Elle remplace toutes les occurrences d‚Äôune variable par un autre terme.
   - Attention au *capture d‚Äôidentifiant* : comment √©viter d‚Äô√©craser une variable libre ?
   - Vous pourriez avoir besoin d‚Äôune fonction auxiliaire pour renommer les variables (alpha-conversion).

---

### üîÅ Partie 3 : R√©duction (Œ≤-reduction)

4. **Impl√©mentez une fonction `reduce_once : term -> term option`**
   - Elle effectue une seule r√©duction Œ≤ si c‚Äôest possible.
   - Travaillez en priorit√© sur les termes les plus √† gauche (ordre normal).

5. **Impl√©mentez une fonction `normalize : term -> term`**
   - Elle applique `reduce_once` autant de fois que n√©cessaire jusqu‚Äô√† obtenir un terme normal.
   - Attention aux boucles infinies ! (optionnel : ajoutez une limite de profondeur).

---

### üß™ Partie 4 : Tests & Termes utiles

6. **Impl√©mentez quelques termes classiques du lambda-calcul :**
   - Identit√© : `Œªx. x`
   - Combinateur K : `Œªx. Œªy. x`
   - Combinateur S : `Œªx. Œªy. Œªz. x z (y z)`
   - Les bool√©ens : `true = Œªt. Œªf. t`, `false = Œªt. Œªf. f`
   - Les entiers de Church : `0 = Œªf. Œªx. x`, `1 = Œªf. Œªx. f x`, etc.

7. **Testez quelques expressions et r√©ductions :**
   - `((Œªx. x) y)` ‚Üí `y`
   - `((Œªx. Œªy. x) a) b` ‚Üí `a`
   - `((Œªf. Œªx. f (f x)) (Œªy. y + 1)) 0` ‚Üí ?

---

### üß† Partie 5 : Bonus (si tu veux aller plus loin)

8. **Impl√©mente une gestion des entr√©es utilisateur :**
   - Un mini-parceur de cha√Ænes vers des termes (ex : `"\\x. x x"` ‚Üí `Lam ("x", App (Var "x", Var "x"))`).

9. **Ajoute une gestion des erreurs :**
   - Par exemple, une exception pour les variables libres non d√©finies.

10. **Explore des extensions :**
   - Ajoute des types simples (calcul des types de Church).
   - G√®re les macros ou la r√©cursion via le combinateur Y.

---